// Для кнопок
// STM32F100x8
//                                     ***** ПАРК АТТРАКЦИОНОВ №02 *****


#include "iostm32f100xB.h"  //здесь определения (адреса и названия) всех регистров, вкладка SFR (Project->SFR Setup)



// ********* Дадим определения типов используемых чисел **********
typedef unsigned long uint32_t;
typedef unsigned short uint16_t;
typedef char uint8_t;



int   key_pressed, timer, timer_led;



//****** Введем функцию задержки, она пригодится в нескольких местах **********
void delay (uint32_t step);    //объявим функцию программной задержки

void delay (uint32_t step)    //сама функция (step=100 000 соответствует 20 мс, 10 000 = 2 мс, 1000 = 200 мкс, 1 ~ 200 нс)
{  while (step > 0)            //значения для тактовой 24 МГц. Правильнее значение выставлять с помощью анализатора
{--step;}
}
// ************************ Конец функции  *************************



//********** Инициализация таймера TIM1 для ШИМ ************
void TIM1_config(void);
void TIM1_config(void)
{
  // ********** Два параметра ниже определяют конфигурацию ШИМ **********
  TIM1_PSC |= 0x00000004;         // прескалер частоты счетчика - чем больше значение, тем ниже частота ШИМ
  TIM1_ARR = 50000;               // автоматически подгружаемое значение - определяет ПЕРИОД импульса ШИМ 
  
  TIM1_CCER  =  0x00000000;       // временно отключили от выхода
  TIM1_CCMR1 |= 0x7070;           // для каналов 1, 2
  TIM1_CCMR2 |= 0x7070;           // для каналов 3, 4
  TIM1_CCER |=  0x00003333;       // регистр сравнения подключили к выводам PA8, PA9 и PA10, PA11
  TIM1_BDTR |=  0x00008000;
  
  TIM1_CCR1 |=  50000;       //************* определяет ширину импульса - процент % заполнения
  TIM1_CCR2 |=  50000;
  TIM1_CCR3 |=  50000;
  TIM1_CCR4 |=  50000;
  
  TIM1_CR1 |=   0x00000001;       // запускаем счетчик 
}

int abs(int i);  //здесь просто декларация встроенной в компилятор функции. Без этого ругается.



//****************** Прерывание по системному таймеру SysTick *******************
void System_timer_config(void);
void System_timer_config(void) 
{    
  SYSTICKRVR = 0x00249F00;    //  Прерывания каждые 0,1 с - интервал между DCC-командами
  SYSTICKCSR = 0x00000007;    
} // *********** Прерывания запущены ************  



int main()
{
  //************** Настройка тактирования кристалла **************
  RCC_CR |= 0x00000001;         // internal 8 MHz RC oscillator ON, PLL еще не включен
  //************** Настройка PLL ***************
  //RCC_CFGR |= 0x00010000;       //источником сигнала выбран HSI / 2
  RCC_CFGR |= 0x00100002;       //установили коэф. умножения 0100 = 6  - здесь верно - 24 МГц
  RCC_CR |= 0x01000000;         //включили PLL
  while ((RCC_CR & 0x02000000) == 0) {   } //Дожидаемся готовности PLL
  RCC_CFGR |= 0x00000002;                  // 10 - PLL выбрали в качестве системного генератора SysTick, 00 - HSI
  while ((RCC_CFGR & 0x00000008) != 0x00000008) {   }  // Wait till PLL is used as system clock source 
  //********************* Настройка тактирования завершена ************************ 
  
  
  
  //*************** Настройка работы портов ***************
  RCC_APB2ENR |= 0x0000182D;    // тактирование портов А, B и D разрешено, тактирование регистров AFIO разрешено, тактирование TIM1 разрешено, SPI разрешено
  RCC_APB1ENR |= 0x20000000;    // тактирование  DAC разрешено
  
  
  
  //*************** Настройка работы портов ***************
  
  GPIOA_CRL = 0x22202444;    //    PA0, PA1 ,PA2- входы герконов; 
  //    PA3 - выъход, статусный светодиод; 
  //    PA4 - аналоговый вход для правильной работы DAC1; 
  //    PA5, PA6, PA7 - выходы на ключи    
  
  GPIOA_CRH = 0x2442AAAA;    //    PA8, PA9, PA10, PA11 - альт. функция TIM1_CH1, TIM1_CH2, TIM1_CH3, TIM1_CH4- ШИМ на EN двигателей,
  //    PA12, PA15 - выходы на управление L293, 
  //    PA13 - SWDIO, PA14 - SWCLK
  
  
  
  GPIOB_CRL = 0x42999222;    //    PB0, PB1, PB2 - выходы на ключи; 
  //    PB3, PB4, PB5 - выход альт. функции для SPI1 (скорость до 10 МГц), push-pull;
  //    PB6 - выход  на CS FLASH;
  //    PB7 - вход логический (на оптрон)
  
  GPIOB_CRH = 0x22222244;    //    PB8 - вход логический (на оптрон),  
  //    PB9 - вход геркона,
  //    PB10...PB15 - выходы на L293 - направление движения
  
  GPIOD_CRL = 0x44444442;    //    PD0 - STBY (выход, включение/выключение усилителя)
  
  
  AFIO_MAPR = 0x02008001;    //    отключили JTAG от пинов PB3, PB4 и сделали их простыми пинами, подключили SPI1,
  //    отключили JTDI от пина PA15 и сделали его простым пином,
  //    подключили PD0 (и PD1) к ножкам осциллятора  
  
  
  
  GPIOA_BSRR = 0x90E00008;   //начальные условия 
  GPIOB_BSRR = 0xFC070040;   //начальные условия
  GPIOD_BSRR = 0x00000001;   //начальные условия - микросхема TDA1517 (усилитель) в режиме Standby (на PD0 высокий уровень) 
  
  
  
  TIM1_config();
  System_timer_config();
  
  
  
  //*********************** Инициализация watchdog ********************  
  IWDG_KR = 0x5555;        //разрешаем запись в PR и RLR
  IWDG_PR = 0x0001;        //prescaler /8
  IWDG_RLR = 0x00000FFF;   //период 819 мс
  IWDG_KR = 0xCCCC;        //запускаем watchdog
  
  
  
  //********** Бесконечный цикл **********
  
  for (;;) 
  {
    // *** время работы аттракциона ***
    if(timer == 1800)               //определяем интервал возможного повторения включения - 1800 = 3 минуты
    {
      timer = 0; key_pressed = 0;
    }    
  }
  
  
}


// ********** Обработчик прерывания **********

void SysTick_Handler (void)
{
  
  IWDG_KR = 0xAAAA;   //сбросили watchdog 
  
  
  // *** включение аттракциона ***
  if(!((GPIOB_IDR & (1 << 7)) < 1))                        // если нет сигнала "Ночь"
  {
    if((GPIOB_IDR & (1 << 8)) < 1) key_pressed = 1;       // если нажата кнопка, отмечаем это флагом выполнения
    
    if((timer > 1) && (timer < 200)) GPIOA_BSRR = 0x000000E0; // включили свет "Осьминога" out1(PA5) и свет "Колеса" out2(PA6), out3(PA7)                    
    else                             {GPIOA_BSRR = 0x00C00000; GPIOA_BSRR = 0x00200000;} // выключили свет "Осьминога" и свет "Колеса"                   
  }
  
  else GPIOA_BSRR = 0x000000E0;  // если есть сигнал "Ночь"
  // включили свет "Осьминога" out1(PA5) и свет "Колеса" out2(PA6), out3(PA7)  
  
  
  if(key_pressed == 1) timer++;  // если флаг равен 1, запускаем аттракцион
  
  
  
  // ******************* УПРАВЛЕНИЕ КАРУСЕЛЬКАМИ *****************************
  
  // "Осьминожка"  *** M1: PA8(TIM1-CH1), PB10, PB11 - двигатель 6v
  //                   out1(PA5) - свет 12V  
  //                   SW1(PA2) - геркон
  
  // "Колесико"    *** M2: PA9(TIM1-CH2), PB12, PB13 - двигатель 6v
  //                   out2(PA6) - свет 12V 
  //                   out3(PA7) - свет 5V   
  
  if((timer > 1) && (timer < 200))                   // интервал 20 секунд
  {
    GPIOA_BSRR = 0x00000100; GPIOB_BSRR = 0x08000400; TIM1_CCR1 = 50000;     // включили двигатель M1
    GPIOA_BSRR = 0x00000200; GPIOB_BSRR = 0x20001000; TIM1_CCR2 = 50000;     // включили двигатель M2
  }
  
  else                                               // если вышли за пределы интервала
  {
    GPIOA_BSRR = 0x01000000; GPIOB_BSRR = 0x0C000000; TIM1_CCR1 = 0;         // выключили двигатель M1
    GPIOA_BSRR = 0x02000000; GPIOB_BSRR = 0x30000000; TIM1_CCR2 = 0;         // выключили двигатель M2
  }         
   
  // *** статусный светодиод ***
  
  if((timer == 0) & (!((GPIOB_IDR & (1 << 7)) < 1)))     // если timer=0 и нет сигнала "Ночь"
  {
    timer_led++;
    if(timer_led == 15)  GPIOA_BSRR = 0x00080000;
    if(timer_led >= 30) {GPIOA_BSRR = 0x00000008; timer_led = 0;}    // редкое мигание светодиода на плате - аттракцион готов к запуску
  }
  
  else  
  { 
    timer_led++;
    if(timer_led == 2)  GPIOA_BSRR = 0x00080000;                   
    if(timer_led >= 5) {GPIOA_BSRR = 0x00000008; timer_led = 0;}     // частое мигание светодиода на плате - аттракцион занят
  }
  
  
  
}


